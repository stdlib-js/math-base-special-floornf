{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isnanf = require( '@stdlib/math-base-assert-is-nanf' );\nvar isInfinitef = require( '@stdlib/math-base-assert-is-infinitef' );\nvar powf = require( '@stdlib/math-base-special-powf' );\nvar absf = require( '@stdlib/math-base-special-absf' );\nvar floorf = require( '@stdlib/math-base-special-floorf' );\nvar MAX_SAFE_INTEGER = require( '@stdlib/constants-float32-max-safe-integer' );\nvar MAX_EXP = require( '@stdlib/constants-float32-max-base10-exponent' );\nvar MIN_EXP = require( '@stdlib/constants-float32-min-base10-exponent' );\nvar MIN_EXP_SUBNORMAL = require( '@stdlib/constants-float32-min-base10-exponent-subnormal' );\nvar NINF = require( '@stdlib/constants-float32-ninf' );\nvar f32 = require( '@stdlib/number-float64-base-to-float32' );\n\n\n// VARIABLES //\n\nvar MAX_INT = MAX_SAFE_INTEGER + 1;\nvar HUGE = f32( 1.0e+38 );\nvar ZERO = f32( 0.0 );\n\n\n// MAIN //\n\n/**\n* Rounds a single-precision floating-point number to the nearest multiple of `10^n` toward negative infinity.\n*\n* ## Method\n*\n* 1.  If \\\\(|x| <= 2^{24}\\\\) and \\\\(|n| <= 38\\\\), we can use the formula\n*\n*     ```tex\n*     \\operatorname{floornf}(x,n) = \\frac{\\operatorname{floor}(x \\cdot 10^{-n})}{10^{-n}}\n*     ```\n*\n*     which shifts the decimal to the nearest multiple of \\\\(10^n\\\\), performs a standard \\\\(\\mathrm{floor}\\\\) operation, and then shifts the decimal to its original position.\n*\n*     <!-- <note> -->\n*\n*     If \\\\(x \\cdot 10^{-n}\\\\) overflows, \\\\(x\\\\) lacks a sufficient number of decimal digits to have any effect when rounding. Accordingly, the rounded value is \\\\(x\\\\).\n*\n*     <!-- </note> -->\n*\n*     <!-- <note> -->\n*\n*     Note that rescaling \\\\(x\\\\) can result in unexpected behavior. For instance, the result of \\\\(\\operatorname{floornf}(-0.2-0.1,-16)\\\\) is \\\\(-0.30000001192092896\\\\) and not \\\\(-0.3\\\\). While possibly unexpected, this is not a bug. The behavior stems from the fact that most decimal fractions cannot be exactly represented as floating-point numbers. And further, rescaling can lead to slightly different fractional values, which, in turn, affects the result of \\\\(\\mathrm{floor}\\\\).\n*\n*     <!-- </note> -->\n*\n* 2.  If \\\\(n > 38\\\\), we recognize that the maximum absolute single-precision floating-point number is \\\\(\\approx 3.4\\mbox{e}38\\\\) and, thus, the result of rounding any possible negative finite number \\\\(x\\\\) to the nearest \\\\(10^n\\\\) is \\\\(-\\infty\\\\) and any possible positive finite number \\\\(x\\\\) is \\\\(+0\\\\). To ensure consistent behavior with \\\\(\\operatorname{floor}(x)\\\\), if \\\\(x > 0\\\\), the sign of \\\\(x\\\\) is preserved.\n*\n* 3.  If \\\\(n < -45\\\\), \\\\(n\\\\) exceeds the maximum number of possible decimal places (such as with subnormal numbers), and, thus, the rounded value is \\\\(x\\\\).\n*\n* 4.  If \\\\(x > 2^{24}\\\\), \\\\(x\\\\) is **always** an integer (i.e., \\\\(x\\\\) has no decimal digits). If \\\\(n <= 0\\\\), the rounded value is \\\\(x\\\\).\n*\n* 5.  If \\\\(n < -38\\\\), we let \\\\(m = n + 38\\\\) and modify the above formula to avoid overflow.\n*\n*     ```tex\n*     \\operatorname{floornf}(x,n) = \\frac{\\biggl(\\frac{\\operatorname{floor}( (x \\cdot 10^{38}) 10^{-m})}{10^{38}}\\biggr)}{10^{-m}}\n*     ```\n*\n*     If overflow occurs, the rounded value is \\\\(x\\\\).\n*\n* ## Special Cases\n*\n* ```tex\n* \\begin{align*}\n* \\operatorname{floornf}(\\mathrm{NaN}, n) &= \\mathrm{NaN} \\\\\n* \\operatorname{floornf}(x, \\mathrm{NaN}) &= \\mathrm{NaN} \\\\\n* \\operatorname{floornf}(x, \\pm\\infty) &= \\mathrm{NaN} \\\\\n* \\operatorname{floornf}(\\pm\\infty, n) &= \\pm\\infty \\\\\n* \\operatorname{floornf}(\\pm 0, n) &= \\pm 0\n* \\end{align*}\n* ```\n*\n* @param {number} x - input value\n* @param {integer} n - integer power of 10\n* @returns {number} rounded value\n*\n* @example\n* // Round a value to 3 decimal places:\n* var v = floornf( 3.14159, -3 );\n* // returns ~3.141\n*\n* @example\n* // Round a value to the nearest thousand:\n* var v = floornf( 12368.0, 3 );\n* // returns ~12000.0\n*\n* @example\n* // If n = 0, `floornf` behaves like `floorf`:\n* var v = floornf( 3.14159, 0 );\n* // returns 3.0\n*/\nfunction floornf( x, n ) {\n\tvar s;\n\tvar y;\n\n\tx = f32( x );\n\tif (\n\t\tisnanf( x ) ||\n\t\tisnanf( n ) ||\n\t\tisInfinitef( n )\n\t) {\n\t\treturn NaN;\n\t}\n\tif (\n\t\t// Handle infinities...\n\t\tisInfinitef( x ) ||\n\n\t\t// Handle +-0...\n\t\tx === ZERO ||\n\n\t\t// If `n` exceeds the maximum number of feasible decimal places (such as with subnormal numbers), nothing to round...\n\t\tn < MIN_EXP_SUBNORMAL ||\n\n\t\t// If `|x|` is large enough, no decimals to round...\n\t\t( absf( x ) > MAX_INT && n <= 0 )\n\t) {\n\t\treturn x;\n\t}\n\t// The maximum absolute single is ~3.4e38. Accordingly, any possible positive finite `x` rounded to the nearest >=10^39 is infinity and any negative finite `x` is zero.\n\tif ( n > MAX_EXP ) {\n\t\tif ( x >= ZERO ) {\n\t\t\treturn ZERO; // preserve the sign (same behavior as floor)\n\t\t}\n\t\treturn NINF;\n\t}\n\t// If we overflow, return `x`, as the number of digits to the right of the decimal is too small (i.e., `x` is too large / lacks sufficient fractional precision) for there to be any effect when rounding...\n\tif ( n < MIN_EXP ) {\n\t\ts = powf( f32( 10.0 ), -(n + MAX_EXP) );\n\t\ty = f32( f32( x * HUGE ) * s );  // order of operation matters!\n\t\tif ( isInfinitef( y ) ) {\n\t\t\treturn x;\n\t\t}\n\t\treturn f32( f32( floorf( y ) / HUGE ) / s );\n\t}\n\ts = powf( f32( 10.0 ), -n );\n\ty = f32( x * s );\n\tif ( isInfinitef( y ) ) {\n\t\treturn x;\n\t}\n\treturn f32( floorf( y ) / s );\n}\n\n\n// EXPORTS //\n\nmodule.exports = floornf;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Round a single-precision floating-point number to the nearest multiple of `10^n` toward negative infinity.\n*\n* @module @stdlib/math-base-special-floornf\n*\n* @example\n* var floornf = require( '@stdlib/math-base-special-floornf' );\n*\n* // Round a value to 3 decimal places:\n* var v = floornf( 3.14159, -3 );\n* // returns ~3.141\n*\n* // Round a value to the nearest thousand:\n* v = floornf( 12368.0, 3 );\n* // returns ~12000.0\n*\n* // If n = 0, `floornf` behaves like `floorf`:\n* v = floornf( 3.14159, 0 );\n* // returns 3.0\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAS,QAAS,kCAAmC,EACrDC,EAAc,QAAS,uCAAwC,EAC/DC,EAAO,QAAS,gCAAiC,EACjDC,EAAO,QAAS,gCAAiC,EACjDC,EAAS,QAAS,kCAAmC,EACrDC,EAAmB,QAAS,4CAA6C,EACzEC,EAAU,QAAS,+CAAgD,EACnEC,EAAU,QAAS,+CAAgD,EACnEC,EAAoB,QAAS,yDAA0D,EACvFC,EAAO,QAAS,gCAAiC,EACjDC,EAAM,QAAS,wCAAyC,EAKxDC,EAAUN,EAAmB,EAC7BO,EAAOF,EAAK,IAAQ,EACpBG,EAAOH,EAAK,CAAI,EA2EpB,SAASI,EAASC,EAAGC,EAAI,CACxB,IAAIC,EACAC,EAGJ,OADAH,EAAIL,EAAKK,CAAE,EAEVf,EAAQe,CAAE,GACVf,EAAQgB,CAAE,GACVf,EAAae,CAAE,EAER,IAIPf,EAAac,CAAE,GAGfA,IAAMF,GAGNG,EAAIR,GAGFL,EAAMY,CAAE,EAAIJ,GAAWK,GAAK,EAEvBD,EAGHC,EAAIV,EACHS,GAAKF,EACFA,EAEDJ,EAGHO,EAAIT,GACRU,EAAIf,EAAMQ,EAAK,EAAK,EAAG,EAAEM,EAAIV,EAAS,EACtCY,EAAIR,EAAKA,EAAKK,EAAIH,CAAK,EAAIK,CAAE,EACxBhB,EAAaiB,CAAE,EACZH,EAEDL,EAAKA,EAAKN,EAAQc,CAAE,EAAIN,CAAK,EAAIK,CAAE,IAE3CA,EAAIf,EAAMQ,EAAK,EAAK,EAAG,CAACM,CAAE,EAC1BE,EAAIR,EAAKK,EAAIE,CAAE,EACVhB,EAAaiB,CAAE,EACZH,EAEDL,EAAKN,EAAQc,CAAE,EAAID,CAAE,EAC7B,CAKAlB,EAAO,QAAUe,IC7HjB,IAAIK,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isnanf", "isInfinitef", "powf", "absf", "floorf", "MAX_SAFE_INTEGER", "MAX_EXP", "MIN_EXP", "MIN_EXP_SUBNORMAL", "NINF", "f32", "MAX_INT", "HUGE", "ZERO", "floornf", "x", "n", "s", "y", "main"]
}
